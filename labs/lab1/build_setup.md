---
title: "Build Setup"
keywords: build_setup
tags: [build_setup]
permalink:  build_setup.html
summary: build_setup
sidebar: home_sidebar
---

To begin here I am assuming you have a local repo, with the SFML submodule.

## Open Visual Studio
- Open AppsAnywhere and launch **Visual Studio Community 2022 C++ cli**.
- Choose the option open local folder
- Once the folder open, create two new file *main.cpp* and *CMakeLists.txt*


## Get Some Code in main.cpp


```cpp
#include <SFML/Graphics.hpp>

int main(){
  sf::RenderWindow window(sf::VideoMode({200, 200}), "SFML works!");
  sf::CircleShape shape(100.f);
  shape.setFillColor(sf::Color::Green);

  while (window.isOpen()){
      sf::Event event;
      while (window.pollEvent(event)){
      if (event.type == sf::Event::Closed){
        window.close();
      }
    }
    window.clear();
    window.draw(shape);
    window.display();
  }
  return 0;
}
```

This is the basic "Hello world" for SFML, we will use this to test everything is in-place and working.

## Building code with CMake

While C++ doesn't have a standardized package and build system (i.e, Pythons's pip, Nodes's npm), we have something that's pretty close: **CMake**

CMake allows you to write a **CMakelists.txt** file. In this you specify what your program is, where the source files are, and where any of it's needed dependencies are. From here CMake will take that config file and make you a perfect already set up Visual Studio solution. No need to touch configuration options in Visual Studio, hooray!

CMake has many more benefits, but what we care about is:
1. You only need to store CMakelists.txt files in your Repo, __**no huge VSsolutions.sln**__
1. CMakelists.txt play nice with git, you can easily see and track changes
1. CMake doesn't just build Visual Studio solutions, it can build Xcode, Clion, Eclipse, makefiles etc. This is an important step in writing cross-platform code.

CMake Downsides:
1. It's yet another new scripting language to learn


### Create the CMake script
```CMake
project(setup)
cmake_minimum_required(VERSION 3.11)
# Require modern C++
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

#### Setup Directories ####
#Main output directory
SET(OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/")
# Ouput all DLLs from all libs into main build folder
SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY})

#### Add External Dependencies ####
add_subdirectory("lib/SFML")
set(SFML_INCS "lib/SFML/include")
link_directories("${CMAKE_BINARY_DIR}/lib/SFML/lib")

#### Practical 1 ####
add_executable(lab_1 main.cpp)
target_include_directories(lab_1 PRIVATE ${SFML_INCS})
target_link_libraries(lab_1 sfml-graphics)
```

While that may look odd, you can generally guess at what every line does. The good news is we'll provide all the CMake code you will need.
**Having said that, it is useful to understand it, so you can debug it!**

At this point, if everything is working properly, you should see a window with a green circle appear when running the project.


## Debugging

Debugging will be essential. VS is a good tool for this. If you hit F5 or go in the drop down menu debugging and click start debugging, your application will start in debug mode.

The first thing to try is to click on the left of the line numbers in the editor. This will set a breakpoint. If you launch again your program with debugging, the execution should stop at this line. Then you should be able to see the current state of your program: which variables are there, what are their values etc...

Play with it for a bit, see what is possible to do. 

## Saving your work
You should take this opportunity to commit and push your work. If you know the basics of git, this is nothing new.
```bash
git status
```
Running git status should show you all the files you have modified so far. We need to "Stage" or "add" these files. 

```bash
git add <each file you want add>
```
This is a shorthand to tell git that we want to commit everything.


```bash
git commit -m "SFML hello world working"
```
Now we run the actual commit, which will store the current version of all your ("Staged")files to the local repo. Note that this is only local, you now need to push it up to github.

```bash
git push origin main
```

This is a light-speed gloss over what version control can do for you. If this is new and strange to you, you really should take some time to look through some online git tutorials and guides to get comfortable with what it does and how it works.

## Starting from scratch
If you want to work on another PC, or at home. You obviously don't need to create a new repo.
The steps you need to do are simply:
1. Clone/Pull the repo down from your github
1. Get/update SFML by running: ```git submodule update --init --recursive```
1. Run CMake to generate your build folder

The key here is that you only need to version control your **source** folder.
The build folder, generated by CMake, is full of large junk that Visual Studio needs. Importantly, you don't need to save this or even really care about what's in there! Hooray!
You can re-generate it anytime anywhere using CMake.

Hopefully you can see why this is a much better way of doing things, for sustainability and for working in teams!


---
Previous step: [Repo setup](repo_setup)
Next step: [Pong](pong)
